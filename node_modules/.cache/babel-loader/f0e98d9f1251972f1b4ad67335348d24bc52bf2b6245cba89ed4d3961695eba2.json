{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport React, { useCallback, useEffect, useMemo, useRef, useState } from \"react\";\nimport BezierEasing from \"bezier-easing\";\n// @ts-ignore\nimport ScrollManager from \"window-scroll-manager\";\n// ------------ Constants\n// Regex that checks for numbers in string\n// formatted as \"{number}{unit}\" where unit is \"px\", \"vh\", \"%\" or none\nconst START_END_DURATION_REGEX = /^-?\\d+(\\.\\d+)?(px|vh|%)?$/;\nconst DEFAULT_UNIT = \"px\";\nconst DEFAULT_ANGLE_UNIT = \"deg\";\nconst ANGLE_PROPERTIES = [\"rotate\", \"rotateX\", \"rotateY\", \"rotateZ\", \"skew\", \"skewX\", \"skewY\", \"skewZ\", \"hueRotate\"];\nconst EASINGS = {\n  ease: [0.25, 0.1, 0.25, 1.0],\n  easeIn: [0.42, 0.0, 1.0, 1.0],\n  easeOut: [0.0, 0.0, 0.58, 1.0],\n  easeInOut: [0.42, 0.0, 0.58, 1.0],\n  easeInSine: [0.47, 0, 0.745, 0.715],\n  easeOutSine: [0.39, 0.575, 0.565, 1],\n  easeInOutSine: [0.445, 0.05, 0.55, 0.95],\n  easeInQuad: [0.55, 0.085, 0.68, 0.53],\n  easeOutQuad: [0.25, 0.46, 0.45, 0.94],\n  easeInOutQuad: [0.455, 0.03, 0.515, 0.955],\n  easeInCubic: [0.55, 0.055, 0.675, 0.19],\n  easeOutCubic: [0.215, 0.61, 0.355, 1],\n  easeInOutCubic: [0.645, 0.045, 0.355, 1],\n  easeInQuart: [0.895, 0.03, 0.685, 0.22],\n  easeOutQuart: [0.165, 0.84, 0.44, 1],\n  easeInOutQuart: [0.77, 0, 0.175, 1],\n  easeInQuint: [0.755, 0.05, 0.855, 0.06],\n  easeOutQuint: [0.23, 1, 0.32, 1],\n  easeInOutQuint: [0.86, 0, 0.07, 1],\n  easeInExpo: [0.95, 0.05, 0.795, 0.035],\n  easeOutExpo: [0.19, 1, 0.22, 1],\n  easeInOutExpo: [1, 0, 0, 1],\n  easeInCirc: [0.6, 0.04, 0.98, 0.335],\n  easeOutCirc: [0.075, 0.82, 0.165, 1],\n  easeInOutCirc: [0.785, 0.135, 0.15, 0.86]\n};\n// Color regex\n// 0 - 199 | 200 - 249 | 250 - 255\nconst REGEX_0_255 = \"(1?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])\";\n// 0.0 - 1.9999...\nconst REGEX_0_1 = \"([01](\\\\.\\\\d+)?)\";\n// 00 - FF\nconst REGEX_TWO_HEX_DIGITS = \"([a-f\\\\d]{2})\";\nconst HEX_REGEX = new RegExp(`^#${REGEX_TWO_HEX_DIGITS}${REGEX_TWO_HEX_DIGITS}${REGEX_TWO_HEX_DIGITS}$`, \"i\");\nconst RGB_REGEX = new RegExp(`^rgb\\\\(${REGEX_0_255},${REGEX_0_255},${REGEX_0_255}\\\\)$`, \"i\");\nconst RGBA_REGEX = new RegExp(`^rgba\\\\(${REGEX_0_255},${REGEX_0_255},${REGEX_0_255},${REGEX_0_1}\\\\)$`, \"i\");\nconst SCROLL_OFFSET = 50;\nconst RESIZE_DEBOUNCE_TIMEOUT = 150;\n// CSS transform map\nconst TRANSFORM_MAP = {\n  rotate: (value, unit = DEFAULT_ANGLE_UNIT) => `rotate(${value}${unit})`,\n  rotateX: (value, unit = DEFAULT_ANGLE_UNIT) => `rotateX(${value}${unit})`,\n  rotateY: (value, unit = DEFAULT_ANGLE_UNIT) => `rotateY(${value}${unit})`,\n  rotateZ: (value, unit = DEFAULT_ANGLE_UNIT) => `rotateZ(${value}${unit})`,\n  scale: value => `scale(${value})`,\n  scaleX: value => `scaleX(${value})`,\n  scaleY: value => `scaleY(${value})`,\n  scaleZ: value => `scaleZ(${value})`,\n  skew: (value, unit = DEFAULT_UNIT) => `skew(${value}${unit})`,\n  skewX: (value, unit = DEFAULT_UNIT) => `skewX(${value}${unit})`,\n  skewY: (value, unit = DEFAULT_UNIT) => `skewY(${value}${unit})`,\n  skewZ: (value, unit = DEFAULT_UNIT) => `skewZ(${value}${unit})`,\n  translateX: (value, unit = DEFAULT_UNIT) => `translateX(${value}${unit})`,\n  translateY: (value, unit = DEFAULT_UNIT) => `translateY(${value}${unit})`,\n  translateZ: (value, unit = DEFAULT_UNIT) => `translateZ(${value}${unit})`\n};\n// Order of CSS transforms matters\nconst ORDER_OF_TRANSFORMS = [\"translateX\", \"translateY\", \"translateZ\", \"skew\", \"skewX\", \"skewY\", \"skewZ\", \"rotate\", \"rotateX\", \"rotateY\", \"rotateZ\", \"scale\", \"scaleX\", \"scaleY\", \"scaleZ\"];\n// CSS properties that use color values\nconst COLOR_PROPERTIES = [\"backgroundColor\", \"borderBottomColor\", \"borderColor\", \"borderLeftColor\", \"borderRightColor\", \"borderTopColor\", \"color\", \"fill\", \"stroke\"];\n// CSS filter map\n// blur()\n// brightness()\n// contrast()\n// grayscale()\n// hue-rotate()\n// invert()\n// opacity() // use opacityFilter\n// saturate()\n// sepia()\n// Not supported\n// drop-shadow()\n// url()\nconst FILTER_MAP = {\n  blur: (value, unit = DEFAULT_UNIT) => `blur(${value}${unit})`,\n  brightness: value => `brightness(${value})`,\n  contrast: value => `contrast(${value})`,\n  grayscale: value => `grayscale(${value})`,\n  hueRotate: (value, unit = DEFAULT_ANGLE_UNIT) => `hue-rotate(${value}${unit})`,\n  invert: value => `invert(${value})`,\n  opacityFilter: value => `opacity(${value})`,\n  saturate: value => `saturate(${value})`,\n  sepia: value => `sepia(${value})`\n};\nconst FILTER_PROPERTIES = [\"blur\", \"brightness\", \"contrast\", \"grayscale\", \"hueRotate\", \"invert\", \"opacityFilter\", \"saturate\", \"sepia\"];\n// ------------ Helpers\n// Get element's top offset\nfunction getElementTop(el) {\n  let top = 0;\n  let element = el;\n  do {\n    top += element.offsetTop || 0;\n    element = element.offsetParent;\n  } while (element);\n  return top;\n}\n// Returns CSS unit\nfunction getUnit(property, unit) {\n  let propertyUnit = unit || DEFAULT_UNIT;\n  if (ANGLE_PROPERTIES.indexOf(property) >= 0) {\n    propertyUnit = unit || DEFAULT_ANGLE_UNIT;\n  }\n  return propertyUnit;\n}\n// Takes string value (in px/vh/%) and returns number\nfunction getValueInPx(value, maxScroll) {\n  var _a;\n  const floatValue = parseFloat(value);\n  const unit = ((_a = value.match(START_END_DURATION_REGEX)) === null || _a === void 0 ? void 0 : _a[2]) || null;\n  const vh = window.innerHeight / 100;\n  let valueInPx;\n  switch (unit) {\n    case \"vh\":\n      valueInPx = vh * floatValue;\n      break;\n    case \"%\":\n      valueInPx = maxScroll * floatValue / 100;\n      break;\n    default:\n      valueInPx = floatValue;\n  }\n  return valueInPx;\n}\n// Takes start/end/duration props\n// and return number (in pixels) based on prop type (number, string, dom element)\nfunction convertPropToPixels(propName, propValue, maxScroll, offset = 0) {\n  let propValueInPx = propValue;\n  const isElement = propValue instanceof HTMLElement;\n  const keyCodes = {\n    ZERO: 48,\n    NINE: 57\n  };\n  if (typeof propValue === \"number\") {\n    propValueInPx = propValue;\n  } else if (START_END_DURATION_REGEX.test(propValue)) {\n    propValueInPx = getValueInPx(propValue, maxScroll);\n  } else if (isElement || typeof propValue === \"string\" && (propValue.charCodeAt(0) < keyCodes.ZERO || propValue.charCodeAt(0) > keyCodes.NINE)) {\n    const element = isElement ? propValue : document.querySelector(propValue);\n    if (!element) {\n      console.warn(`Plx, ERROR: ${propName} selector matches no elements: \"${propValue}\"`);\n      return null;\n    }\n    if (propName === \"start\" || propName === \"end\") {\n      // START or END\n      // Element enters the viewport\n      propValueInPx = getElementTop(element) - window.innerHeight;\n    } else if (propName === \"duration\") {\n      // DURATION\n      // Height of the element\n      propValueInPx = element.offsetHeight;\n    }\n  } else {\n    console.warn(`Plx, ERROR: \"${propValue}\" is not a valid ${propName} value, check documentation`);\n    return null;\n  }\n  // Transform offset to px\n  let offsetInPx = 0;\n  if (typeof offset === \"number\") {\n    offsetInPx = offset;\n  } else if (START_END_DURATION_REGEX.test(offset)) {\n    offsetInPx = getValueInPx(offset, maxScroll);\n  }\n  // Add offset\n  propValueInPx += offsetInPx;\n  if (propValueInPx < 0) {\n    propValueInPx = 0;\n  }\n  return propValueInPx;\n}\n// Converts color in hex format into object { r, g, b, a }\nfunction hexToObject(hex) {\n  // Convert #abc to #aabbcc\n  const color = hex.length === 4 ? `#${hex[1]}${hex[1]}${hex[2]}${hex[2]}${hex[3]}${hex[3]}` : hex;\n  const result = HEX_REGEX.exec(color);\n  // Safety check, if color is in the wrong format\n  if (!result) {\n    console.warn(`Plx, ERROR: hex color is not in the right format: \"${hex}\"`);\n    return null;\n  }\n  // All color functions are returning { r, g, b, a } object\n  return {\n    r: parseInt(result[1], 16),\n    g: parseInt(result[2], 16),\n    b: parseInt(result[3], 16),\n    a: 1\n  };\n}\n// Converts color in rgb format into object { r, g, b, a }\nfunction rgbToObject(rgb) {\n  const isRgba = rgb.toLowerCase().indexOf(\"rgba\") === 0;\n  const color = rgb.replace(/ /g, \"\");\n  const result = isRgba ? RGBA_REGEX.exec(color) : RGB_REGEX.exec(color);\n  // Safety check, if color is in the wrong format\n  if (!result) {\n    console.warn(`Plx, ERROR: rgb or rgba color is not in the right format: \"${rgb}\"`);\n    return null;\n  }\n  // All color functions are returning { r, g, b, a } object\n  return {\n    r: parseInt(result[1], 10),\n    g: parseInt(result[2], 10),\n    b: parseInt(result[3], 10),\n    a: isRgba ? parseFloat(result[4]) : 1\n  };\n}\n// Calculates the current value for parallax-ing property\nfunction parallax(scrollPosition, start, duration, startValue, endValue, easing) {\n  // Safety check, if \"startValue\" is in the wrong format\n  if (typeof startValue !== \"number\") {\n    console.warn(`Plx, ERROR: startValue is not a number (type: \"${typeof endValue}\", value: \"${endValue}\")`);\n    return 0;\n  }\n  // Safety check, if \"endValue\" is in the wrong format\n  if (typeof endValue !== \"number\") {\n    console.warn(`Plx, ERROR: endValue is not a number (type: \"${typeof endValue}\", value: \"${endValue}\")`);\n    return 0;\n  }\n  // Safety check, if \"duration\" is in the wrong format\n  if (typeof duration !== \"number\" || duration === 0) {\n    console.warn(`Plx, ERROR: duration is zero or not a number (type: \"${typeof duration}\", value: \"${duration}\")`);\n    return 0;\n  }\n  let min = startValue;\n  let max = endValue;\n  const invert = startValue > endValue;\n  if (invert) {\n    min = endValue;\n    max = startValue;\n  }\n  let percentage = (scrollPosition - start) / duration;\n  if (percentage > 1) {\n    percentage = 1;\n  } else if (percentage < 0) {\n    percentage = 0;\n  }\n  // Apply easing\n  if (easing) {\n    if (Array.isArray(easing)) {\n      percentage = BezierEasing(easing[0], easing[1], easing[2], easing[3])(percentage);\n    } else if (typeof easing === \"string\" && EASINGS[easing]) {\n      percentage = BezierEasing(EASINGS[easing][0], EASINGS[easing][1], EASINGS[easing][2], EASINGS[easing][3])(percentage);\n    } else if (typeof easing === \"function\") {\n      percentage = easing(percentage);\n    }\n  }\n  let value = percentage * (max - min);\n  if (invert) {\n    value = max - value;\n  } else {\n    value += min;\n  }\n  // Rounding to 4 decimals (.toFixed(4) returns a string)\n  return Math.floor(value * 10000) / 10000;\n}\n// Calculates current value for color parallax\nfunction colorParallax(scrollPosition, start, duration, startValue, endValue, easing) {\n  let startObject = null;\n  let endObject = null;\n  if (typeof startValue === \"string\") {\n    if (startValue[0].toLowerCase() === \"r\") {\n      startObject = rgbToObject(startValue);\n    } else {\n      startObject = hexToObject(startValue);\n    }\n  }\n  if (typeof endValue === \"string\") {\n    if (endValue[0].toLowerCase() === \"r\") {\n      endObject = rgbToObject(endValue);\n    } else {\n      endObject = hexToObject(endValue);\n    }\n  }\n  if (startObject && endObject) {\n    const r = parallax(scrollPosition, start, duration, startObject.r, endObject.r, easing);\n    const g = parallax(scrollPosition, start, duration, startObject.g, endObject.g, easing);\n    const b = parallax(scrollPosition, start, duration, startObject.b, endObject.b, easing);\n    const a = parallax(scrollPosition, start, duration, startObject.a, endObject.a, easing);\n    return `rgba(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)}, ${a})`;\n  }\n  return \"\";\n}\n// Applies property parallax to the style object\nfunction applyPropertyToStyle(scrollPosition, propertyData, startPosition, duration, style, transforms, filters, easing) {\n  const {\n    startValue,\n    endValue,\n    property,\n    unit\n  } = propertyData;\n  // If property is one of the color properties\n  // Use it's parallax method\n  const isColor = COLOR_PROPERTIES.indexOf(property) > -1;\n  const parallaxMethod = isColor ? colorParallax : parallax;\n  // Get new CSS value\n  const value = parallaxMethod(scrollPosition, startPosition, duration, startValue, endValue, easing);\n  // Get transform function\n  const transformMethod = TRANSFORM_MAP[property];\n  const filterMethod = FILTER_MAP[property];\n  const newStyle = style;\n  if (transformMethod) {\n    // Get CSS unit\n    const propertyUnit = getUnit(property, unit);\n    // Transforms, apply value to transform function\n    transforms[property] = transformMethod(value, propertyUnit);\n  } else if (filterMethod) {\n    // Get CSS unit\n    const propertyUnit = getUnit(property, unit);\n    // Filters, apply value to filter function\n    filters[property] = filterMethod(value, propertyUnit);\n  } else {\n    // All other properties\n    newStyle[property] = value;\n    // Add unit if it is passed\n    if (unit) {\n      newStyle[property] += unit;\n    }\n  }\n}\n// Returns CSS classes based on animation state\nfunction getClasses(lastSegmentScrolledBy, isInSegment, parallaxData) {\n  let cssClasses = \"\";\n  if (lastSegmentScrolledBy === null) {\n    cssClasses = \"Plx--above\";\n  } else if (lastSegmentScrolledBy === parallaxData.length - 1 && !isInSegment) {\n    cssClasses = \"Plx--below\";\n  } else if (lastSegmentScrolledBy !== null && isInSegment) {\n    const segmentName = parallaxData[lastSegmentScrolledBy].name || lastSegmentScrolledBy;\n    cssClasses = `Plx--active Plx--in Plx--in-${segmentName}`;\n  } else if (lastSegmentScrolledBy !== null && !isInSegment) {\n    const segmentName = parallaxData[lastSegmentScrolledBy].name || lastSegmentScrolledBy;\n    const nextSegmentName = parallaxData[lastSegmentScrolledBy + 1].name || lastSegmentScrolledBy + 1;\n    cssClasses = `Plx--active Plx--between Plx--between-${segmentName}-and-${nextSegmentName}`;\n  }\n  return cssClasses;\n}\n// Checks if class contains 'active'\nfunction checkIsActive(classes) {\n  return classes.indexOf(\"Plx--active\") > -1;\n}\n// Main update function\n// Returns new state object based on props and scroll position\nfunction updateDOM(scrollPosition, props, showElement, propsUsedInParallax, plxStyleRef, plxStateClassesRef, elementRef) {\n  const {\n    animateWhenNotInViewport,\n    disabled,\n    freeze,\n    parallaxData,\n    className,\n    onPlxEnd,\n    onPlxStart,\n    style\n  } = props;\n  const plxStyle = plxStyleRef.current;\n  const plxStateClasses = plxStateClassesRef.current;\n  const element = elementRef.current;\n  // Do nothing if animation is disabled, frozen\n  // or if element is not rendered yet\n  if (freeze && showElement || !element || disabled) {\n    return;\n  }\n  // Check if element is in viewport\n  // Small offset is added to prevent page jumping\n  if (!animateWhenNotInViewport) {\n    const rect = element.getBoundingClientRect();\n    const isTopAboveBottomEdge = rect.top < window.innerHeight + SCROLL_OFFSET;\n    const isBottomBelowTopEdge = rect.top + rect.height > -SCROLL_OFFSET;\n    if (!isTopAboveBottomEdge || !isBottomBelowTopEdge) {\n      return;\n    }\n  }\n  // Style to be applied to our element\n  let newStyle = {};\n  const transforms = {};\n  const filters = {};\n  const appliedProperties = [];\n  const segments = [];\n  let isInSegment = false;\n  let lastSegmentScrolledBy = null;\n  const bodyHeight = document.documentElement.scrollHeight || document.body.scrollHeight;\n  const maxScroll = bodyHeight - window.innerHeight;\n  for (let i = 0; i < parallaxData.length; i++) {\n    const {\n      duration,\n      easing,\n      endOffset,\n      properties,\n      startOffset\n    } = parallaxData[i];\n    const start = parallaxData[i].start === \"self\" ? element : parallaxData[i].start;\n    const end = parallaxData[i].end === \"self\" ? element : parallaxData[i].end;\n    const startInPx = convertPropToPixels(\"start\", start, maxScroll, startOffset);\n    let durationInPx;\n    let endInPx;\n    // End has higher priority than duration\n    if (typeof end !== \"undefined\") {\n      endInPx = convertPropToPixels(\"end\", end, maxScroll, endOffset);\n      durationInPx = endInPx - startInPx;\n    } else {\n      durationInPx = convertPropToPixels(\"duration\", duration, maxScroll);\n      endInPx = startInPx + durationInPx;\n    }\n    // If segment is below scroll position skip it\n    if (scrollPosition < startInPx) {\n      break;\n    }\n    const isScrolledByStart = scrollPosition >= startInPx;\n    if (isScrolledByStart) {\n      lastSegmentScrolledBy = i;\n    }\n    // If active segment exists, apply his properties\n    if (scrollPosition >= startInPx && scrollPosition <= endInPx) {\n      isInSegment = true;\n      properties.forEach(propertyData => {\n        const {\n          property\n        } = propertyData;\n        // Save which properties are applied to the active segment\n        // So they are not re-applied for other segments\n        appliedProperties.push(property);\n        // Apply property style\n        applyPropertyToStyle(scrollPosition, propertyData, startInPx, durationInPx, newStyle, transforms, filters, easing);\n      });\n    } else {\n      // Push non active segments above the scroll position to separate array\n      // This way \"durationInPx\" and \"startInPx\" are not calculated again\n      // and segments below scroll position are skipped in the next step\n      segments.push({\n        easing,\n        durationInPx,\n        properties,\n        startInPx\n      });\n    }\n  }\n  // These are only segments that are completely above scroll position\n  segments.forEach(data => {\n    const {\n      easing,\n      durationInPx,\n      properties,\n      startInPx\n    } = data;\n    properties.forEach(propertyData => {\n      const {\n        property\n      } = propertyData;\n      // Skip property that was changed for active segment\n      if (appliedProperties.indexOf(property) > -1) {\n        return;\n      }\n      // These styles that are the ones changed by segments\n      // that are above active segment\n      applyPropertyToStyle(scrollPosition, propertyData, startInPx, durationInPx, newStyle, transforms, filters, easing);\n    });\n  });\n  // Sort transforms by ORDER_OF_TRANSFORMS\n  // as order of CSS transforms matters\n  const transformsOrdered = [];\n  ORDER_OF_TRANSFORMS.forEach(transformKey => {\n    if (transforms[transformKey]) {\n      transformsOrdered.push(transforms[transformKey]);\n    }\n  });\n  // Concat transforms and add webkit prefix\n  newStyle.transform = transformsOrdered.join(\" \");\n  newStyle.webkitTransform = newStyle.transform;\n  const filtersArray = [];\n  FILTER_PROPERTIES.forEach(filterKey => {\n    if (filters[filterKey]) {\n      filtersArray.push(filters[filterKey]);\n    }\n  });\n  // Concat filters and add webkit prefix\n  newStyle.filter = filtersArray.join(\" \");\n  newStyle.webkitFilter = newStyle.filter;\n  // \"Stupid\" check if style should be updated\n  if (JSON.stringify(plxStyle) !== JSON.stringify(newStyle)) {\n    // Set styles\n    requestAnimationFrame(() => {\n      // Add user styles\n      for (const property in style) {\n        // @ts-ignore\n        element.style[property] = style[property];\n      }\n      // Add parallax styles\n      propsUsedInParallax.forEach(property => {\n        // @ts-ignore\n        element.style[property] = typeof newStyle[property] === \"undefined\" ? \"\" : newStyle[property];\n      });\n    });\n    plxStyleRef.current = newStyle;\n  }\n  // Adding state classes\n  const newPlxStateClasses = getClasses(lastSegmentScrolledBy, isInSegment, parallaxData);\n  if (newPlxStateClasses !== plxStateClasses) {\n    const newClassName = `${className} Plx ${newPlxStateClasses}`;\n    if (newClassName !== element.className) {\n      const wasActive = checkIsActive(element.className);\n      const isActive = checkIsActive(newClassName);\n      element.className = newClassName;\n      // Callbacks\n      if (!wasActive && isActive) {\n        onPlxStart === null || onPlxStart === void 0 ? void 0 : onPlxStart();\n      } else if (wasActive && !isActive) {\n        onPlxEnd === null || onPlxEnd === void 0 ? void 0 : onPlxEnd();\n      }\n    }\n    // Cache plx classes\n    plxStateClassesRef.current = newPlxStateClasses;\n  }\n}\nconst Plx = props => {\n  const {\n      animateWhenNotInViewport = false,\n      children,\n      className = \"\",\n      disabled = false,\n      freeze = false,\n      parallaxData,\n      style = {},\n      onPlxStart,\n      onPlxEnd,\n      tagName: ElementTag = \"div\"\n    } = props,\n    elementProps = __rest(props, [\"animateWhenNotInViewport\", \"children\", \"className\", \"disabled\", \"freeze\", \"parallaxData\", \"style\", \"onPlxStart\", \"onPlxEnd\", \"tagName\"]);\n  const scrollManager = useRef();\n  const resizeTimeout = useRef();\n  const element = useRef(null);\n  const plxStyle = useRef({});\n  const plxStyleClasses = useRef(\"\");\n  const [showElement, setShowElement] = useState(false);\n  // Get properties that are used in a parallax effect\n  const propsUsedInParallax = useMemo(() => {\n    const properties = [];\n    parallaxData.forEach(segment => {\n      segment.properties.forEach(({\n        property\n      }) => {\n        const transformMethod = TRANSFORM_MAP[property];\n        const filterMethod = FILTER_MAP[property];\n        if (transformMethod) {\n          if (!properties.includes(\"transform\")) {\n            properties.push(\"transform\", \"webkitTransform\");\n          }\n        } else if (filterMethod) {\n          if (!properties.includes(\"filter\")) {\n            properties.push(\"filter\", \"webkitFilter\");\n          }\n        } else {\n          if (!properties.includes(property)) {\n            properties.push(property);\n          }\n        }\n      });\n    });\n    return properties;\n  }, [parallaxData]);\n  // Set will-change property\n  useEffect(() => {\n    if (element.current) {\n      element.current.style.willChange = propsUsedInParallax.map(str => {\n        return str.replace(/[A-Z]/g, letter => `-${letter.toLowerCase()}`).replace(\"webkit\", \"-webkit\");\n      }).join(\",\");\n    }\n  }, [element, propsUsedInParallax]);\n  const update = useCallback((scrollPosition = null) => {\n    const currentScrollPosition = scrollPosition === null ? scrollManager.current.getScrollPosition().scrollPositionY : scrollPosition;\n    updateDOM(currentScrollPosition, props, showElement, propsUsedInParallax, plxStyle, plxStyleClasses, element);\n  }, [props]);\n  // Window resize\n  const handleResize = useCallback(() => {\n    clearTimeout(resizeTimeout.current);\n    resizeTimeout.current = setTimeout(() => {\n      update();\n    }, RESIZE_DEBOUNCE_TIMEOUT);\n  }, [props]);\n  useEffect(() => {\n    if (scrollManager.current) {\n      if (disabled) {\n        // When disabled leave only user styles\n        propsUsedInParallax.forEach(property => {\n          if (element.current) {\n            // @ts-ignore\n            element.current.style[property] = \"\";\n          }\n        });\n      } else {\n        update();\n      }\n    }\n  }, [disabled]);\n  // Window scroll\n  const handleScrollChange = useCallback(e => {\n    update(e.detail.scrollPositionY);\n  }, [props]);\n  useEffect(() => {\n    // Get scroll manager singleton\n    scrollManager.current = new ScrollManager();\n    // Add listeners\n    window.addEventListener(\"window-scroll\", handleScrollChange);\n    window.addEventListener(\"resize\", handleResize);\n    update();\n    setShowElement(true);\n    return () => {\n      clearTimeout(resizeTimeout.current);\n      window.removeEventListener(\"window-scroll\", handleScrollChange);\n      window.removeEventListener(\"resize\", handleResize);\n      scrollManager.current.removeListener();\n    };\n  }, [props]);\n  // Update DOM on props change\n  useEffect(() => {\n    update();\n  }, []);\n  let elementStyle = style;\n  if (!disabled) {\n    elementStyle = Object.assign(Object.assign({}, style), {\n      // Hide element before until it is rendered\n      // This prevents jumps if page is scrolled and then refreshed\n      visibility: showElement ? undefined : \"hidden\"\n    });\n  }\n  return React.createElement(ElementTag, Object.assign({}, elementProps, {\n    className: `${className} Plx`,\n    style: elementStyle,\n    ref: element\n  }), children);\n};\nexport default Plx;","map":{"version":3,"names":["__rest","s","e","t","p","Object","prototype","hasOwnProperty","call","indexOf","getOwnPropertySymbols","i","length","propertyIsEnumerable","React","useCallback","useEffect","useMemo","useRef","useState","BezierEasing","ScrollManager","START_END_DURATION_REGEX","DEFAULT_UNIT","DEFAULT_ANGLE_UNIT","ANGLE_PROPERTIES","EASINGS","ease","easeIn","easeOut","easeInOut","easeInSine","easeOutSine","easeInOutSine","easeInQuad","easeOutQuad","easeInOutQuad","easeInCubic","easeOutCubic","easeInOutCubic","easeInQuart","easeOutQuart","easeInOutQuart","easeInQuint","easeOutQuint","easeInOutQuint","easeInExpo","easeOutExpo","easeInOutExpo","easeInCirc","easeOutCirc","easeInOutCirc","REGEX_0_255","REGEX_0_1","REGEX_TWO_HEX_DIGITS","HEX_REGEX","RegExp","RGB_REGEX","RGBA_REGEX","SCROLL_OFFSET","RESIZE_DEBOUNCE_TIMEOUT","TRANSFORM_MAP","rotate","value","unit","rotateX","rotateY","rotateZ","scale","scaleX","scaleY","scaleZ","skew","skewX","skewY","skewZ","translateX","translateY","translateZ","ORDER_OF_TRANSFORMS","COLOR_PROPERTIES","FILTER_MAP","blur","brightness","contrast","grayscale","hueRotate","invert","opacityFilter","saturate","sepia","FILTER_PROPERTIES","getElementTop","el","top","element","offsetTop","offsetParent","getUnit","property","propertyUnit","getValueInPx","maxScroll","_a","floatValue","parseFloat","match","vh","window","innerHeight","valueInPx","convertPropToPixels","propName","propValue","offset","propValueInPx","isElement","HTMLElement","keyCodes","ZERO","NINE","test","charCodeAt","document","querySelector","console","warn","offsetHeight","offsetInPx","hexToObject","hex","color","result","exec","r","parseInt","g","b","a","rgbToObject","rgb","isRgba","toLowerCase","replace","parallax","scrollPosition","start","duration","startValue","endValue","easing","min","max","percentage","Array","isArray","Math","floor","colorParallax","startObject","endObject","round","applyPropertyToStyle","propertyData","startPosition","style","transforms","filters","isColor","parallaxMethod","transformMethod","filterMethod","newStyle","getClasses","lastSegmentScrolledBy","isInSegment","parallaxData","cssClasses","segmentName","name","nextSegmentName","checkIsActive","classes","updateDOM","props","showElement","propsUsedInParallax","plxStyleRef","plxStateClassesRef","elementRef","animateWhenNotInViewport","disabled","freeze","className","onPlxEnd","onPlxStart","plxStyle","current","plxStateClasses","rect","getBoundingClientRect","isTopAboveBottomEdge","isBottomBelowTopEdge","height","appliedProperties","segments","bodyHeight","documentElement","scrollHeight","body","endOffset","properties","startOffset","end","startInPx","durationInPx","endInPx","isScrolledByStart","forEach","push","data","transformsOrdered","transformKey","transform","join","webkitTransform","filtersArray","filterKey","filter","webkitFilter","JSON","stringify","requestAnimationFrame","newPlxStateClasses","newClassName","wasActive","isActive","Plx","children","tagName","ElementTag","elementProps","scrollManager","resizeTimeout","plxStyleClasses","setShowElement","segment","includes","willChange","map","str","letter","update","currentScrollPosition","getScrollPosition","scrollPositionY","handleResize","clearTimeout","setTimeout","handleScrollChange","detail","addEventListener","removeEventListener","removeListener","elementStyle","assign","visibility","undefined","createElement","ref"],"sources":["/Users/mithileshkumaar/Desktop/codings/portfolio/node_modules/react-plx/dist/esm/index.js"],"sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport React, { useCallback, useEffect, useMemo, useRef, useState, } from \"react\";\nimport BezierEasing from \"bezier-easing\";\n// @ts-ignore\nimport ScrollManager from \"window-scroll-manager\";\n// ------------ Constants\n// Regex that checks for numbers in string\n// formatted as \"{number}{unit}\" where unit is \"px\", \"vh\", \"%\" or none\nconst START_END_DURATION_REGEX = /^-?\\d+(\\.\\d+)?(px|vh|%)?$/;\nconst DEFAULT_UNIT = \"px\";\nconst DEFAULT_ANGLE_UNIT = \"deg\";\nconst ANGLE_PROPERTIES = [\"rotate\", \"rotateX\", \"rotateY\", \"rotateZ\", \"skew\", \"skewX\", \"skewY\", \"skewZ\", \"hueRotate\"];\nconst EASINGS = {\n    ease: [0.25, 0.1, 0.25, 1.0],\n    easeIn: [0.42, 0.0, 1.0, 1.0],\n    easeOut: [0.0, 0.0, 0.58, 1.0],\n    easeInOut: [0.42, 0.0, 0.58, 1.0],\n    easeInSine: [0.47, 0, 0.745, 0.715],\n    easeOutSine: [0.39, 0.575, 0.565, 1],\n    easeInOutSine: [0.445, 0.05, 0.55, 0.95],\n    easeInQuad: [0.55, 0.085, 0.68, 0.53],\n    easeOutQuad: [0.25, 0.46, 0.45, 0.94],\n    easeInOutQuad: [0.455, 0.03, 0.515, 0.955],\n    easeInCubic: [0.55, 0.055, 0.675, 0.19],\n    easeOutCubic: [0.215, 0.61, 0.355, 1],\n    easeInOutCubic: [0.645, 0.045, 0.355, 1],\n    easeInQuart: [0.895, 0.03, 0.685, 0.22],\n    easeOutQuart: [0.165, 0.84, 0.44, 1],\n    easeInOutQuart: [0.77, 0, 0.175, 1],\n    easeInQuint: [0.755, 0.05, 0.855, 0.06],\n    easeOutQuint: [0.23, 1, 0.32, 1],\n    easeInOutQuint: [0.86, 0, 0.07, 1],\n    easeInExpo: [0.95, 0.05, 0.795, 0.035],\n    easeOutExpo: [0.19, 1, 0.22, 1],\n    easeInOutExpo: [1, 0, 0, 1],\n    easeInCirc: [0.6, 0.04, 0.98, 0.335],\n    easeOutCirc: [0.075, 0.82, 0.165, 1],\n    easeInOutCirc: [0.785, 0.135, 0.15, 0.86],\n};\n// Color regex\n// 0 - 199 | 200 - 249 | 250 - 255\nconst REGEX_0_255 = \"(1?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])\";\n// 0.0 - 1.9999...\nconst REGEX_0_1 = \"([01](\\\\.\\\\d+)?)\";\n// 00 - FF\nconst REGEX_TWO_HEX_DIGITS = \"([a-f\\\\d]{2})\";\nconst HEX_REGEX = new RegExp(`^#${REGEX_TWO_HEX_DIGITS}${REGEX_TWO_HEX_DIGITS}${REGEX_TWO_HEX_DIGITS}$`, \"i\");\nconst RGB_REGEX = new RegExp(`^rgb\\\\(${REGEX_0_255},${REGEX_0_255},${REGEX_0_255}\\\\)$`, \"i\");\nconst RGBA_REGEX = new RegExp(`^rgba\\\\(${REGEX_0_255},${REGEX_0_255},${REGEX_0_255},${REGEX_0_1}\\\\)$`, \"i\");\nconst SCROLL_OFFSET = 50;\nconst RESIZE_DEBOUNCE_TIMEOUT = 150;\n// CSS transform map\nconst TRANSFORM_MAP = {\n    rotate: (value, unit = DEFAULT_ANGLE_UNIT) => `rotate(${value}${unit})`,\n    rotateX: (value, unit = DEFAULT_ANGLE_UNIT) => `rotateX(${value}${unit})`,\n    rotateY: (value, unit = DEFAULT_ANGLE_UNIT) => `rotateY(${value}${unit})`,\n    rotateZ: (value, unit = DEFAULT_ANGLE_UNIT) => `rotateZ(${value}${unit})`,\n    scale: (value) => `scale(${value})`,\n    scaleX: (value) => `scaleX(${value})`,\n    scaleY: (value) => `scaleY(${value})`,\n    scaleZ: (value) => `scaleZ(${value})`,\n    skew: (value, unit = DEFAULT_UNIT) => `skew(${value}${unit})`,\n    skewX: (value, unit = DEFAULT_UNIT) => `skewX(${value}${unit})`,\n    skewY: (value, unit = DEFAULT_UNIT) => `skewY(${value}${unit})`,\n    skewZ: (value, unit = DEFAULT_UNIT) => `skewZ(${value}${unit})`,\n    translateX: (value, unit = DEFAULT_UNIT) => `translateX(${value}${unit})`,\n    translateY: (value, unit = DEFAULT_UNIT) => `translateY(${value}${unit})`,\n    translateZ: (value, unit = DEFAULT_UNIT) => `translateZ(${value}${unit})`,\n};\n// Order of CSS transforms matters\nconst ORDER_OF_TRANSFORMS = [\n    \"translateX\",\n    \"translateY\",\n    \"translateZ\",\n    \"skew\",\n    \"skewX\",\n    \"skewY\",\n    \"skewZ\",\n    \"rotate\",\n    \"rotateX\",\n    \"rotateY\",\n    \"rotateZ\",\n    \"scale\",\n    \"scaleX\",\n    \"scaleY\",\n    \"scaleZ\",\n];\n// CSS properties that use color values\nconst COLOR_PROPERTIES = [\n    \"backgroundColor\",\n    \"borderBottomColor\",\n    \"borderColor\",\n    \"borderLeftColor\",\n    \"borderRightColor\",\n    \"borderTopColor\",\n    \"color\",\n    \"fill\",\n    \"stroke\",\n];\n// CSS filter map\n// blur()\n// brightness()\n// contrast()\n// grayscale()\n// hue-rotate()\n// invert()\n// opacity() // use opacityFilter\n// saturate()\n// sepia()\n// Not supported\n// drop-shadow()\n// url()\nconst FILTER_MAP = {\n    blur: (value, unit = DEFAULT_UNIT) => `blur(${value}${unit})`,\n    brightness: (value) => `brightness(${value})`,\n    contrast: (value) => `contrast(${value})`,\n    grayscale: (value) => `grayscale(${value})`,\n    hueRotate: (value, unit = DEFAULT_ANGLE_UNIT) => `hue-rotate(${value}${unit})`,\n    invert: (value) => `invert(${value})`,\n    opacityFilter: (value) => `opacity(${value})`,\n    saturate: (value) => `saturate(${value})`,\n    sepia: (value) => `sepia(${value})`,\n};\nconst FILTER_PROPERTIES = [\n    \"blur\",\n    \"brightness\",\n    \"contrast\",\n    \"grayscale\",\n    \"hueRotate\",\n    \"invert\",\n    \"opacityFilter\",\n    \"saturate\",\n    \"sepia\",\n];\n// ------------ Helpers\n// Get element's top offset\nfunction getElementTop(el) {\n    let top = 0;\n    let element = el;\n    do {\n        top += element.offsetTop || 0;\n        element = element.offsetParent;\n    } while (element);\n    return top;\n}\n// Returns CSS unit\nfunction getUnit(property, unit) {\n    let propertyUnit = unit || DEFAULT_UNIT;\n    if (ANGLE_PROPERTIES.indexOf(property) >= 0) {\n        propertyUnit = unit || DEFAULT_ANGLE_UNIT;\n    }\n    return propertyUnit;\n}\n// Takes string value (in px/vh/%) and returns number\nfunction getValueInPx(value, maxScroll) {\n    var _a;\n    const floatValue = parseFloat(value);\n    const unit = ((_a = value.match(START_END_DURATION_REGEX)) === null || _a === void 0 ? void 0 : _a[2]) || null;\n    const vh = window.innerHeight / 100;\n    let valueInPx;\n    switch (unit) {\n        case \"vh\":\n            valueInPx = vh * floatValue;\n            break;\n        case \"%\":\n            valueInPx = (maxScroll * floatValue) / 100;\n            break;\n        default:\n            valueInPx = floatValue;\n    }\n    return valueInPx;\n}\n// Takes start/end/duration props\n// and return number (in pixels) based on prop type (number, string, dom element)\nfunction convertPropToPixels(propName, propValue, maxScroll, offset = 0) {\n    let propValueInPx = propValue;\n    const isElement = propValue instanceof HTMLElement;\n    const keyCodes = {\n        ZERO: 48,\n        NINE: 57,\n    };\n    if (typeof propValue === \"number\") {\n        propValueInPx = propValue;\n    }\n    else if (START_END_DURATION_REGEX.test(propValue)) {\n        propValueInPx = getValueInPx(propValue, maxScroll);\n    }\n    else if (isElement ||\n        (typeof propValue === \"string\" &&\n            (propValue.charCodeAt(0) < keyCodes.ZERO || propValue.charCodeAt(0) > keyCodes.NINE))) {\n        const element = isElement ? propValue : document.querySelector(propValue);\n        if (!element) {\n            console.warn(`Plx, ERROR: ${propName} selector matches no elements: \"${propValue}\"`);\n            return null;\n        }\n        if (propName === \"start\" || propName === \"end\") {\n            // START or END\n            // Element enters the viewport\n            propValueInPx = getElementTop(element) - window.innerHeight;\n        }\n        else if (propName === \"duration\") {\n            // DURATION\n            // Height of the element\n            propValueInPx = element.offsetHeight;\n        }\n    }\n    else {\n        console.warn(`Plx, ERROR: \"${propValue}\" is not a valid ${propName} value, check documentation`);\n        return null;\n    }\n    // Transform offset to px\n    let offsetInPx = 0;\n    if (typeof offset === \"number\") {\n        offsetInPx = offset;\n    }\n    else if (START_END_DURATION_REGEX.test(offset)) {\n        offsetInPx = getValueInPx(offset, maxScroll);\n    }\n    // Add offset\n    propValueInPx += offsetInPx;\n    if (propValueInPx < 0) {\n        propValueInPx = 0;\n    }\n    return propValueInPx;\n}\n// Converts color in hex format into object { r, g, b, a }\nfunction hexToObject(hex) {\n    // Convert #abc to #aabbcc\n    const color = hex.length === 4 ? `#${hex[1]}${hex[1]}${hex[2]}${hex[2]}${hex[3]}${hex[3]}` : hex;\n    const result = HEX_REGEX.exec(color);\n    // Safety check, if color is in the wrong format\n    if (!result) {\n        console.warn(`Plx, ERROR: hex color is not in the right format: \"${hex}\"`);\n        return null;\n    }\n    // All color functions are returning { r, g, b, a } object\n    return {\n        r: parseInt(result[1], 16),\n        g: parseInt(result[2], 16),\n        b: parseInt(result[3], 16),\n        a: 1,\n    };\n}\n// Converts color in rgb format into object { r, g, b, a }\nfunction rgbToObject(rgb) {\n    const isRgba = rgb.toLowerCase().indexOf(\"rgba\") === 0;\n    const color = rgb.replace(/ /g, \"\");\n    const result = isRgba ? RGBA_REGEX.exec(color) : RGB_REGEX.exec(color);\n    // Safety check, if color is in the wrong format\n    if (!result) {\n        console.warn(`Plx, ERROR: rgb or rgba color is not in the right format: \"${rgb}\"`);\n        return null;\n    }\n    // All color functions are returning { r, g, b, a } object\n    return {\n        r: parseInt(result[1], 10),\n        g: parseInt(result[2], 10),\n        b: parseInt(result[3], 10),\n        a: isRgba ? parseFloat(result[4]) : 1,\n    };\n}\n// Calculates the current value for parallax-ing property\nfunction parallax(scrollPosition, start, duration, startValue, endValue, easing) {\n    // Safety check, if \"startValue\" is in the wrong format\n    if (typeof startValue !== \"number\") {\n        console.warn(`Plx, ERROR: startValue is not a number (type: \"${typeof endValue}\", value: \"${endValue}\")`);\n        return 0;\n    }\n    // Safety check, if \"endValue\" is in the wrong format\n    if (typeof endValue !== \"number\") {\n        console.warn(`Plx, ERROR: endValue is not a number (type: \"${typeof endValue}\", value: \"${endValue}\")`);\n        return 0;\n    }\n    // Safety check, if \"duration\" is in the wrong format\n    if (typeof duration !== \"number\" || duration === 0) {\n        console.warn(`Plx, ERROR: duration is zero or not a number (type: \"${typeof duration}\", value: \"${duration}\")`);\n        return 0;\n    }\n    let min = startValue;\n    let max = endValue;\n    const invert = startValue > endValue;\n    if (invert) {\n        min = endValue;\n        max = startValue;\n    }\n    let percentage = (scrollPosition - start) / duration;\n    if (percentage > 1) {\n        percentage = 1;\n    }\n    else if (percentage < 0) {\n        percentage = 0;\n    }\n    // Apply easing\n    if (easing) {\n        if (Array.isArray(easing)) {\n            percentage = BezierEasing(easing[0], easing[1], easing[2], easing[3])(percentage);\n        }\n        else if (typeof easing === \"string\" && EASINGS[easing]) {\n            percentage = BezierEasing(EASINGS[easing][0], EASINGS[easing][1], EASINGS[easing][2], EASINGS[easing][3])(percentage);\n        }\n        else if (typeof easing === \"function\") {\n            percentage = easing(percentage);\n        }\n    }\n    let value = percentage * (max - min);\n    if (invert) {\n        value = max - value;\n    }\n    else {\n        value += min;\n    }\n    // Rounding to 4 decimals (.toFixed(4) returns a string)\n    return Math.floor(value * 10000) / 10000;\n}\n// Calculates current value for color parallax\nfunction colorParallax(scrollPosition, start, duration, startValue, endValue, easing) {\n    let startObject = null;\n    let endObject = null;\n    if (typeof startValue === \"string\") {\n        if (startValue[0].toLowerCase() === \"r\") {\n            startObject = rgbToObject(startValue);\n        }\n        else {\n            startObject = hexToObject(startValue);\n        }\n    }\n    if (typeof endValue === \"string\") {\n        if (endValue[0].toLowerCase() === \"r\") {\n            endObject = rgbToObject(endValue);\n        }\n        else {\n            endObject = hexToObject(endValue);\n        }\n    }\n    if (startObject && endObject) {\n        const r = parallax(scrollPosition, start, duration, startObject.r, endObject.r, easing);\n        const g = parallax(scrollPosition, start, duration, startObject.g, endObject.g, easing);\n        const b = parallax(scrollPosition, start, duration, startObject.b, endObject.b, easing);\n        const a = parallax(scrollPosition, start, duration, startObject.a, endObject.a, easing);\n        return `rgba(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)}, ${a})`;\n    }\n    return \"\";\n}\n// Applies property parallax to the style object\nfunction applyPropertyToStyle(scrollPosition, propertyData, startPosition, duration, style, transforms, filters, easing) {\n    const { startValue, endValue, property, unit } = propertyData;\n    // If property is one of the color properties\n    // Use it's parallax method\n    const isColor = COLOR_PROPERTIES.indexOf(property) > -1;\n    const parallaxMethod = isColor ? colorParallax : parallax;\n    // Get new CSS value\n    const value = parallaxMethod(scrollPosition, startPosition, duration, startValue, endValue, easing);\n    // Get transform function\n    const transformMethod = TRANSFORM_MAP[property];\n    const filterMethod = FILTER_MAP[property];\n    const newStyle = style;\n    if (transformMethod) {\n        // Get CSS unit\n        const propertyUnit = getUnit(property, unit);\n        // Transforms, apply value to transform function\n        transforms[property] = transformMethod(value, propertyUnit);\n    }\n    else if (filterMethod) {\n        // Get CSS unit\n        const propertyUnit = getUnit(property, unit);\n        // Filters, apply value to filter function\n        filters[property] = filterMethod(value, propertyUnit);\n    }\n    else {\n        // All other properties\n        newStyle[property] = value;\n        // Add unit if it is passed\n        if (unit) {\n            newStyle[property] += unit;\n        }\n    }\n}\n// Returns CSS classes based on animation state\nfunction getClasses(lastSegmentScrolledBy, isInSegment, parallaxData) {\n    let cssClasses = \"\";\n    if (lastSegmentScrolledBy === null) {\n        cssClasses = \"Plx--above\";\n    }\n    else if (lastSegmentScrolledBy === parallaxData.length - 1 && !isInSegment) {\n        cssClasses = \"Plx--below\";\n    }\n    else if (lastSegmentScrolledBy !== null && isInSegment) {\n        const segmentName = parallaxData[lastSegmentScrolledBy].name || lastSegmentScrolledBy;\n        cssClasses = `Plx--active Plx--in Plx--in-${segmentName}`;\n    }\n    else if (lastSegmentScrolledBy !== null && !isInSegment) {\n        const segmentName = parallaxData[lastSegmentScrolledBy].name || lastSegmentScrolledBy;\n        const nextSegmentName = parallaxData[lastSegmentScrolledBy + 1].name || lastSegmentScrolledBy + 1;\n        cssClasses = `Plx--active Plx--between Plx--between-${segmentName}-and-${nextSegmentName}`;\n    }\n    return cssClasses;\n}\n// Checks if class contains 'active'\nfunction checkIsActive(classes) {\n    return classes.indexOf(\"Plx--active\") > -1;\n}\n// Main update function\n// Returns new state object based on props and scroll position\nfunction updateDOM(scrollPosition, props, showElement, propsUsedInParallax, plxStyleRef, plxStateClassesRef, elementRef) {\n    const { animateWhenNotInViewport, disabled, freeze, parallaxData, className, onPlxEnd, onPlxStart, style } = props;\n    const plxStyle = plxStyleRef.current;\n    const plxStateClasses = plxStateClassesRef.current;\n    const element = elementRef.current;\n    // Do nothing if animation is disabled, frozen\n    // or if element is not rendered yet\n    if ((freeze && showElement) || !element || disabled) {\n        return;\n    }\n    // Check if element is in viewport\n    // Small offset is added to prevent page jumping\n    if (!animateWhenNotInViewport) {\n        const rect = element.getBoundingClientRect();\n        const isTopAboveBottomEdge = rect.top < window.innerHeight + SCROLL_OFFSET;\n        const isBottomBelowTopEdge = rect.top + rect.height > -SCROLL_OFFSET;\n        if (!isTopAboveBottomEdge || !isBottomBelowTopEdge) {\n            return;\n        }\n    }\n    // Style to be applied to our element\n    let newStyle = {};\n    const transforms = {};\n    const filters = {};\n    const appliedProperties = [];\n    const segments = [];\n    let isInSegment = false;\n    let lastSegmentScrolledBy = null;\n    const bodyHeight = document.documentElement.scrollHeight || document.body.scrollHeight;\n    const maxScroll = bodyHeight - window.innerHeight;\n    for (let i = 0; i < parallaxData.length; i++) {\n        const { duration, easing, endOffset, properties, startOffset } = parallaxData[i];\n        const start = parallaxData[i].start === \"self\" ? element : parallaxData[i].start;\n        const end = parallaxData[i].end === \"self\" ? element : parallaxData[i].end;\n        const startInPx = convertPropToPixels(\"start\", start, maxScroll, startOffset);\n        let durationInPx;\n        let endInPx;\n        // End has higher priority than duration\n        if (typeof end !== \"undefined\") {\n            endInPx = convertPropToPixels(\"end\", end, maxScroll, endOffset);\n            durationInPx = endInPx - startInPx;\n        }\n        else {\n            durationInPx = convertPropToPixels(\"duration\", duration, maxScroll);\n            endInPx = startInPx + durationInPx;\n        }\n        // If segment is below scroll position skip it\n        if (scrollPosition < startInPx) {\n            break;\n        }\n        const isScrolledByStart = scrollPosition >= startInPx;\n        if (isScrolledByStart) {\n            lastSegmentScrolledBy = i;\n        }\n        // If active segment exists, apply his properties\n        if (scrollPosition >= startInPx && scrollPosition <= endInPx) {\n            isInSegment = true;\n            properties.forEach((propertyData) => {\n                const { property } = propertyData;\n                // Save which properties are applied to the active segment\n                // So they are not re-applied for other segments\n                appliedProperties.push(property);\n                // Apply property style\n                applyPropertyToStyle(scrollPosition, propertyData, startInPx, durationInPx, newStyle, transforms, filters, easing);\n            });\n        }\n        else {\n            // Push non active segments above the scroll position to separate array\n            // This way \"durationInPx\" and \"startInPx\" are not calculated again\n            // and segments below scroll position are skipped in the next step\n            segments.push({\n                easing,\n                durationInPx,\n                properties,\n                startInPx,\n            });\n        }\n    }\n    // These are only segments that are completely above scroll position\n    segments.forEach((data) => {\n        const { easing, durationInPx, properties, startInPx } = data;\n        properties.forEach((propertyData) => {\n            const { property } = propertyData;\n            // Skip property that was changed for active segment\n            if (appliedProperties.indexOf(property) > -1) {\n                return;\n            }\n            // These styles that are the ones changed by segments\n            // that are above active segment\n            applyPropertyToStyle(scrollPosition, propertyData, startInPx, durationInPx, newStyle, transforms, filters, easing);\n        });\n    });\n    // Sort transforms by ORDER_OF_TRANSFORMS\n    // as order of CSS transforms matters\n    const transformsOrdered = [];\n    ORDER_OF_TRANSFORMS.forEach((transformKey) => {\n        if (transforms[transformKey]) {\n            transformsOrdered.push(transforms[transformKey]);\n        }\n    });\n    // Concat transforms and add webkit prefix\n    newStyle.transform = transformsOrdered.join(\" \");\n    newStyle.webkitTransform = newStyle.transform;\n    const filtersArray = [];\n    FILTER_PROPERTIES.forEach((filterKey) => {\n        if (filters[filterKey]) {\n            filtersArray.push(filters[filterKey]);\n        }\n    });\n    // Concat filters and add webkit prefix\n    newStyle.filter = filtersArray.join(\" \");\n    newStyle.webkitFilter = newStyle.filter;\n    // \"Stupid\" check if style should be updated\n    if (JSON.stringify(plxStyle) !== JSON.stringify(newStyle)) {\n        // Set styles\n        requestAnimationFrame(() => {\n            // Add user styles\n            for (const property in style) {\n                // @ts-ignore\n                element.style[property] = style[property];\n            }\n            // Add parallax styles\n            propsUsedInParallax.forEach((property) => {\n                // @ts-ignore\n                element.style[property] = typeof newStyle[property] === \"undefined\" ? \"\" : newStyle[property];\n            });\n        });\n        plxStyleRef.current = newStyle;\n    }\n    // Adding state classes\n    const newPlxStateClasses = getClasses(lastSegmentScrolledBy, isInSegment, parallaxData);\n    if (newPlxStateClasses !== plxStateClasses) {\n        const newClassName = `${className} Plx ${newPlxStateClasses}`;\n        if (newClassName !== element.className) {\n            const wasActive = checkIsActive(element.className);\n            const isActive = checkIsActive(newClassName);\n            element.className = newClassName;\n            // Callbacks\n            if (!wasActive && isActive) {\n                onPlxStart === null || onPlxStart === void 0 ? void 0 : onPlxStart();\n            }\n            else if (wasActive && !isActive) {\n                onPlxEnd === null || onPlxEnd === void 0 ? void 0 : onPlxEnd();\n            }\n        }\n        // Cache plx classes\n        plxStateClassesRef.current = newPlxStateClasses;\n    }\n}\nconst Plx = (props) => {\n    const { animateWhenNotInViewport = false, children, className = \"\", disabled = false, freeze = false, parallaxData, style = {}, onPlxStart, onPlxEnd, tagName: ElementTag = \"div\" } = props, elementProps = __rest(props, [\"animateWhenNotInViewport\", \"children\", \"className\", \"disabled\", \"freeze\", \"parallaxData\", \"style\", \"onPlxStart\", \"onPlxEnd\", \"tagName\"]);\n    const scrollManager = useRef();\n    const resizeTimeout = useRef();\n    const element = useRef(null);\n    const plxStyle = useRef({});\n    const plxStyleClasses = useRef(\"\");\n    const [showElement, setShowElement] = useState(false);\n    // Get properties that are used in a parallax effect\n    const propsUsedInParallax = useMemo(() => {\n        const properties = [];\n        parallaxData.forEach((segment) => {\n            segment.properties.forEach(({ property }) => {\n                const transformMethod = TRANSFORM_MAP[property];\n                const filterMethod = FILTER_MAP[property];\n                if (transformMethod) {\n                    if (!properties.includes(\"transform\")) {\n                        properties.push(\"transform\", \"webkitTransform\");\n                    }\n                }\n                else if (filterMethod) {\n                    if (!properties.includes(\"filter\")) {\n                        properties.push(\"filter\", \"webkitFilter\");\n                    }\n                }\n                else {\n                    if (!properties.includes(property)) {\n                        properties.push(property);\n                    }\n                }\n            });\n        });\n        return properties;\n    }, [parallaxData]);\n    // Set will-change property\n    useEffect(() => {\n        if (element.current) {\n            element.current.style.willChange = propsUsedInParallax\n                .map((str) => {\n                return str.replace(/[A-Z]/g, (letter) => `-${letter.toLowerCase()}`).replace(\"webkit\", \"-webkit\");\n            })\n                .join(\",\");\n        }\n    }, [element, propsUsedInParallax]);\n    const update = useCallback((scrollPosition = null) => {\n        const currentScrollPosition = scrollPosition === null ? scrollManager.current.getScrollPosition().scrollPositionY : scrollPosition;\n        updateDOM(currentScrollPosition, props, showElement, propsUsedInParallax, plxStyle, plxStyleClasses, element);\n    }, [props]);\n    // Window resize\n    const handleResize = useCallback(() => {\n        clearTimeout(resizeTimeout.current);\n        resizeTimeout.current = setTimeout(() => {\n            update();\n        }, RESIZE_DEBOUNCE_TIMEOUT);\n    }, [props]);\n    useEffect(() => {\n        if (scrollManager.current) {\n            if (disabled) {\n                // When disabled leave only user styles\n                propsUsedInParallax.forEach((property) => {\n                    if (element.current) {\n                        // @ts-ignore\n                        element.current.style[property] = \"\";\n                    }\n                });\n            }\n            else {\n                update();\n            }\n        }\n    }, [disabled]);\n    // Window scroll\n    const handleScrollChange = useCallback((e) => {\n        update(e.detail.scrollPositionY);\n    }, [props]);\n    useEffect(() => {\n        // Get scroll manager singleton\n        scrollManager.current = new ScrollManager();\n        // Add listeners\n        window.addEventListener(\"window-scroll\", handleScrollChange);\n        window.addEventListener(\"resize\", handleResize);\n        update();\n        setShowElement(true);\n        return () => {\n            clearTimeout(resizeTimeout.current);\n            window.removeEventListener(\"window-scroll\", handleScrollChange);\n            window.removeEventListener(\"resize\", handleResize);\n            scrollManager.current.removeListener();\n        };\n    }, [props]);\n    // Update DOM on props change\n    useEffect(() => {\n        update();\n    }, []);\n    let elementStyle = style;\n    if (!disabled) {\n        elementStyle = Object.assign(Object.assign({}, style), { \n            // Hide element before until it is rendered\n            // This prevents jumps if page is scrolled and then refreshed\n            visibility: showElement ? undefined : \"hidden\" });\n    }\n    return (React.createElement(ElementTag, Object.assign({}, elementProps, { className: `${className} Plx`, style: elementStyle, ref: element }), children));\n};\nexport default Plx;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}